#! usr/bin/python
from __future__ import print_function, division, absolute_import
import os
import sys
import multiprocessing as mp
from time import time
from argparse import ArgumentParser
import logging

import numpy as np
from disvis import DisVis, PDB, Volume
from disvis.helpers import get_queue
from disvis.rotations import proportional_orientations, quat_to_rotmat


def parse_args():
    p = ArgumentParser()

    p.add_argument('receptor', type=str, 
            help='PDB-file containing fixed chain.')

    p.add_argument('ligand', type=str, 
            help='PDB-file containing scanning chain.')

    p.add_argument('constraints', type=str, 
            help='File containing the distance constraints')

    p.add_argument('-a', '--angle', dest='angle', type=float, default=10,
            help='Rotational sampling density in degrees')

    p.add_argument('-vs', '--voxelspacing', dest='voxelspacing', 
            type=float, default=1,
            help='Voxel spacing of search grid in angstrom.')

    p.add_argument('-ir', '--interaction-radius', 
            dest='interaction_radius', type=float, default=4.0,
            help='Radius of the spherical space filled by average atom in anstrom.')

    p.add_argument('-ei', '--erosion_iterations', 
            dest='erosion_iterations', type=int, default=5,
            help='Number of erosion iterations to apply on the fixed '
                 'chain space. This determines the thickness of the '
                 'interacting shell.')

    p.add_argument('-cv', '--max_clash', 
            dest='max_clash', type=float, default=25,
            help='Maximum allowed volume of clashes. Increasing this '
                 'number results in more allowed complexes.')

    p.add_argument('-iv', '--min-interaction', 
            dest='min_interaction', type=float, default=100,
            help='Minimal required interaction volume for a '
                 'conformation to be considered a '
                 'complex. Increasing this number results in a '
                 'stricter counting of complexes.')

    p.add_argument('-p', '--nproc', dest='nproc', type=int, default=1,
            help='Number of processors used during search.')

    p.add_argument('-g', '--gpu', dest='gpu', action='store_true',
            help='Use GPU-acceleration for search. If not available '
                 'the CPU-version will be used with the given number '
                 'of processors.')

    return p.parse_args()


def parse_constraints(fid, pdb1, pdb2):

    dist_constraints = []
    for line in open(fid):
        # ignore comments and empty lines
        line = line.strip()
        if line.startswith('#') or not line:
            continue
        chain1, resi1, name1, chain2, resi2, name2, distance = line.split()
        pdb1_sel = pdb1.select('chain', chain1).select('resi', int(resi1)).select('name', name1).duplicate()
        pdb2_sel = pdb2.select('chain', chain2).select('resi', int(resi2)).select('name', name2).duplicate()
        dist_constraints.append([pdb1_sel, pdb2_sel, float(distance)])
    return dist_constraints


def run_disvis_instance(queue, receptor, ligand, distance_constraints, rotmat, weights, n, args):

    dv = DisVis()

    dv.receptor = receptor
    dv.ligand = ligand
    dv.distance_restraints = distance_constraints
    dv.rotations = rotmat
    dv.weights = weights

    dv.voxelspacing = args.voxelspacing
    dv.interaction_radius = args.interaction_radius
    dv.erosion_iterations = args.erosion_iterations
    dv.max_clash = args.max_clash
    dv.min_interaction = args.min_interaction

    ais, complexes = dv.search()

    ais.tofile('accessible_interaction_space_{:d}.mrc'.format(n))

    queue.put(complexes)


def mp_cpu_disvis(receptor, ligand, rotmat, weights, distance_constraints, args):

    # multi-threaded CPU version
    try:
        max_cpu  = mp.cpu_count()
        jobs = min(max_cpu, args.nproc)
    except NotImplementedError:
        jobs = args.nproc
    # in case more processes are requiested than the number 
    # of rotations sampled
    nrot = rotmat.shape[0]
    if jobs > nrot:
        jobs = nrot
    nrot_per_job = nrot//jobs
    write('Number of processors used: {:d}'.format(jobs))

    write('Creating jobs')

    queue = mp.Queue()
    processes = []
    for n in range(jobs):


        init_rot = n * nrot_per_job
        end_rot = (n + 1) * nrot_per_job
        if n == (jobs - 1):
            end_rot = None

        sub_rotmat = rotmat[init_rot: end_rot]
        sub_weights = weights[init_rot: end_rot]

        distance_constraints = parse_constraints(args.constraints, PDB.fromfile(args.receptor), PDB.fromfile(args.ligand))

        process = mp.Process(target=run_disvis_instance,
            args=(queue, receptor, ligand, distance_constraints, sub_rotmat, sub_weights, n, args))

        processes.append(process)


    write('Starting jobs')
    for n in range(jobs):
        processes[n].start()
    write('Waiting for jobs to finish')

    for n in range(jobs):
        processes[n].join()
    write('Searching done. Combining results')

    accessible_complexes = np.asarray(queue.get(), dtype=np.float64)
    accessible_interaction_space = Volume.fromfile('accessible_interaction_space_0.mrc')
    for n in range(1, jobs):
        accessible_complexes += np.asarray(queue.get(), dtype=np.float64)
        np.maximum(accessible_interaction_space.array, 
                Volume.fromfile('accessible_interaction_space_{:d}.mrc'.format(n)).array, 
                accessible_interaction_space.array)


    write('Cleaning')
    for n in range(jobs):
        os.remove('accessible_interaction_space_{:d}.mrc'.format(n))

    return accessible_interaction_space, accessible_complexes


def run_disvis(queue, receptor, ligand, rotmat, weights, distance_constraints, args):

    dv = DisVis()

    dv.receptor = receptor
    dv.ligand = ligand
    dv.distance_restraints = distance_constraints
    dv.rotations = rotmat
    dv.weights = weights

    dv.voxelspacing = args.voxelspacing
    dv.interaction_radius = args.interaction_radius
    dv.erosion_iterations = args.erosion_iterations
    dv.max_clash = args.max_clash
    dv.min_interaction = args.min_interaction
    dv.queue = queue

    return dv.search()


def write(line):
    if sys.stdout.isatty():
        print(line)
    logging.info(line)


def main():

    args = parse_args()

    logging.basicConfig(filename='disvis.log', 
            level=logging.INFO, format='%(asctime)s %(message)s')

    time0 = time()

    receptor = PDB.fromfile(args.receptor)
    ligand = PDB.fromfile(args.ligand)
    q, weights, a = proportional_orientations(args.angle)
    rotmat = quat_to_rotmat(q)
    write('Number of rotations: {:d}'.format(rotmat.shape[0]))

    distance_constraints = parse_constraints(args.constraints, receptor, ligand)
    write('Number of distance constraints: {:d}'.format(len(distance_constraints)))

    queue = None
    if args.gpu:
        queue = get_queue()

    if queue is None:
        # CPU-version
        if args.nproc > 1:
            accessible_interaction_space, accessible_complexes = \
                    mp_cpu_disvis(receptor, ligand, rotmat, weights, distance_constraints, args)
        else:
            accessible_interaction_space, accessible_complexes = \
                    run_disvis(queue, receptor, ligand, rotmat, weights, distance_constraints, args)
    else:
        # GPU-version
         accessible_interaction_space, accessible_complexes = \
                 run_disvis(queue, receptor, ligand, rotmat, weights, distance_constraints, args)

    seconds = int(round(time() - time0))
    m, s = divmod(seconds, 60)
    write('Total time: {:2d}m{:2d}s'.format(m, s))
    accessible_interaction_space.tofile('accessible_interaction_space.mrc')
    norm = accessible_complexes[0]
    for n, acc in enumerate(accessible_complexes):
        write('Number of complexes consistent with at least {:d} constraint: {:d} ({:8.4%})'.format(n, int(acc), acc/norm))
        

if __name__=='__main__':
    main()
