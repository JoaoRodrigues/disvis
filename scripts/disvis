#! usr/bin/python
from __future__ import print_function, division, absolute_import
import os
import multiprocessing as mp
from time import time
from argparse import ArgumentParser
import logging
from datetime import timedelta

import numpy as np
from disvis import DisVis, PDB, Volume
from disvis.helpers import get_queue
from disvis.rotations import proportional_orientations, quat_to_rotmat

logging.basicConfig(filename='disvis.log', 
        level=logging.INFO, format='%(asctime)s %(message)s')

def parse_args():
    p = ArgumentParser()

    p.add_argument('receptor', type=str, 
            help='PDB-file containing fixed chain.')
    p.add_argument('ligand', type=str, 
            help='PDB-file containing scanning chain.')
    p.add_argument('constraints', type=str, 
            help='File containing the constraints')

    p.add_argument('-a', '--angle', dest='angle', type=float, default=10,
            help='Angular interval for rotational search in degrees')

    p.add_argument('-vs', '--voxelspacing', dest='voxelspacing', 
            type=float, default=1,
            help='Voxel spacing of search grid in angstrom.')

    p.add_argument('-ir', '--interaction-radius', 
            dest='interaction_radius', type=float, default=3.0,
            help='Radius of the spherical space filled by average atom in anstrom.')

    p.add_argument('-ei', '--erosion_iterations', 
            dest='erosion_iterations', type=int, default=2,
            help='Number of erosion iterations to apply on the fixed ' +\
                 'chain space. This determines the thickness of the ' + \
                 'interacting shell.')

    p.add_argument('-cv', '--max_clash', 
            dest='max_clash', type=float, default=25,
            help='Maximum allowed volume of clashes. Increasing this '+\
                 'number results in more allowed complexes.')

    p.add_argument('-iv', '--min-interaction', 
            dest='min_interaction', type=float, default=100,
            help='Minimal required interaction volume for a ' +\
                 'conformation to be considered a ' +\
                 'complex. Increasing this number results in a '+\
                 'stricter counting of complexes.')

    p.add_argument('-p', '--nproc', dest='nproc', type=int, default=1,
            help='Number of processors used duing search.')

    p.add_argument('-g', '--gpu', dest='gpu', action='store_true',
            help='Use GPU-acceleration for search. If not available '+\
                 'the CPU-version will be used with the given number '+\
                 'of processors.')

    return p.parse_args()

def parse_constraints(fid, pdb1, pdb2):

    dist_constraints = []
    for line in open(fid):
        # ignore comments and empty lines
        if line.startswith('#') or not line.strip():
            continue
        chain1, resi1, name1, chain2, resi2, name2, distance = line.split()
        pdb1_sel = pdb1.select('chain', chain1).select('resi', int(resi1)).select('name', name1).duplicate()
        pdb2_sel = pdb2.select('chain', chain2).select('resi', int(resi2)).select('name', name2).duplicate()
        dist_constraints.append([pdb1_sel, pdb2_sel, float(distance)])
    return dist_constraints


def run_disvis_instance(queue, distance_constraints, rotmat, weights, n, args):

    dv = DisVis()

    dv.receptor = PDB.fromfile(args.receptor)
    dv.ligand = PDB.fromfile(args.ligand)
    dv.distance_restraints = distance_constraints
    dv.rotations = rotmat
    dv.weights = weights

    dv.voxelspacing = args.voxelspacing
    dv.interaction_radius = args.interaction_radius
    dv.erosion_iterations = args.erosion_iterations
    dv.max_clash = args.max_clash
    dv.min_interaction = args.min_interaction

    ais, complexes = dv.search()

    ais.tofile('accessible_interaction_space_{:d}.mrc.part'.format(n))

    queue.put(complexes)

def write(*line):
    for l in line:
        if sys.stdout.isatty():
            print(line)
        logging.info(line)

if __name__=='__main__':

    args = parse_args()
    time0 = time()

    q, weights, a = proportional_orientations(args.angle)
    rotmat = quat_to_rotmat(q)
    nrot = rotmat.shape[0]
    print('Number of rotations: {:d}'.format(rotmat.shape[0]))

    distance_constraints = parse_constraints(args.constraints, PDB.fromfile(args.receptor), PDB.fromfile(args.ligand))
    print('Number of distance constraints: {:d}'.format(len(distance_constraints)))

    queue = None
    if args.gpu:
        queue = get_queue()

    if queue is None:
        # multi-threaded CPU version
        try:
            max_cpu  = mp.cpu_count()
            jobs = min(max_cpu, args.nproc)
        except NotImplementedError:
            jobs = args.nproc
        # in case more processes are requiested than the number 
        # of rotations sampled
        if jobs > nrot:
            jobs = nrot
        nrot_per_job = nrot//jobs
        print('Number of processors used: ', jobs)

        print('Creating jobs')

        queue = mp.Queue()
        processes = []
        for n in range(jobs):


            init_rot = n * nrot_per_job
            end_rot = (n + 1) * nrot_per_job

            sub_rotmat = rotmat[init_rot: end_rot]
            sub_weights = weights[init_rot: end_rot]
            if n == (jobs - 1):
                sub_rotmat = rotmat[init_rot:]
                sub_weights = weights[init_rot:]

            distance_constraints = parse_constraints(args.constraints, PDB.fromfile(args.receptor), PDB.fromfile(args.ligand))

            process = mp.Process(target=run_disvis_instance,
                args=(queue, distance_constraints, sub_rotmat, sub_weights, n, args))

            processes.append(process)


        print('Starting jobs')
        for n in range(jobs):
            processes[n].start()
        print('Waiting for jobs to finish')

        for n in range(jobs):
            processes[n].join()
        print('Searching done. Combining results')

        accessible_complexes = np.asarray(queue.get(), dtype=np.float64)
        accessible_interaction_space = Volume.fromfile('accessible_interaction_space_0.mrc.part')
        for n in range(1, jobs):
            accessible_complexes += np.asarray(queue.get(), dtype=np.float64)
            np.maximum(accessible_interaction_space.array, 
                    Volume.fromfile('accessible_interaction_space_{:d}.mrc.part'.format(n)).array, 
                    accessible_interaction_space.array)


        print('Cleaning')
        for n in range(jobs):
            os.remove('accessible_interaction_space_{:d}.mrc.part'.format(n))
    else:
        # GPU-version
        dv = DisVis()

        dv.receptor = PDB.fromfile(args.receptor)
        dv.ligand = PDB.fromfile(args.ligand)
        dv.distance_restraints = distance_constraints
        dv.rotations = rotmat
        dv.weights = weights

        dv.voxelspacing = args.voxelspacing
        dv.interaction_radius = args.interaction_radius
        dv.erosion_iterations = args.erosion_iterations
        dv.max_clash = args.max_clash
        dv.min_interaction = args.min_interaction
        dv.queue = queue

        accessible_interaction_space, accessible_complexes = dv.search()

    seconds = int(round(time() - time0))
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    print('Total time: {:d}h{:2d}m{:2d}s'.format(h, m, s))
    accessible_interaction_space.tofile('accessible_interaction_space.mrc')
    norm = accessible_complexes[0]
    for n, acc in enumerate(accessible_complexes):
        print('Number of complexes consistent with at least {:d} constraint: {:d} ({:8.4%})'.format(n, int(acc), acc/norm))
        
